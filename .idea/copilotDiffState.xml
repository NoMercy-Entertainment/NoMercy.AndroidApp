<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/tv/nomercy/app/shared/stores/CardStore.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/tv/nomercy/app/shared/stores/CardStore.kt" />
              <option name="originalContent" value="package tv.nomercy.app.shared.stores&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import tv.nomercy.app.shared.repositories.CardsRepository&#10;import tv.nomercy.app.shared.models.Component&#10;&#10;class CardsStore(&#10;    context: Context,&#10;    authStore: AuthStore,&#10;    private val serverConfigStore: ServerConfigStore&#10;) {&#10;    private val authService = GlobalStores.getAuthService(context)&#10;    private val repository = CardsRepository(context, authStore, authService)&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private val _cardItems = MutableStateFlow&lt;Map&lt;String, List&lt;Component&gt;&gt;&gt;(emptyMap())&#10;    val cardItems: StateFlow&lt;Map&lt;String, List&lt;Component&gt;&gt;&gt; = _cardItems.asStateFlow()&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()&#10;&#10;    private fun getServerUrl(): String? = serverConfigStore.currentServer.value?.serverApiUrl&#10;&#10;    @Suppress(&quot;unused&quot;)&#10;    // Existing generic fetch by link&#10;    fun fetchCardItems(link: String, force: Boolean = false) {&#10;        val serverUrl = getServerUrl() ?: run {&#10;            _error.value = &quot;No server selected&quot;&#10;            return&#10;        }&#10;&#10;        if (!force &amp;&amp; _cardItems.value.containsKey(link)) return&#10;&#10;        scope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;&#10;            repository.getCardItems(serverUrl, link).collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { items -&gt;&#10;                        _cardItems.update { it + (link to items) }&#10;                    },&#10;                    onFailure = { _error.value = it.message ?: &quot;Failed to fetch items for $link&quot; }&#10;                )&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // New: fetch paginated letter-based cards (always use letter API)&#10;    fun fetchCards(type: String, char: Char = '_', force: Boolean = false) {&#10;        val serverUrl = getServerUrl() ?: run {&#10;            _error.value = &quot;No server selected&quot;&#10;            return&#10;        }&#10;&#10;&#10;        val link = &quot;music/$type/$char&quot;&#10;&#10;        if (!force &amp;&amp; _cardItems.value.containsKey(link)) return&#10;&#10;        val char = if (char == '#') '_' else char&#10;&#10;        scope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;&#10;            repository.fetchCards(serverUrl, type, char).collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { items -&gt;&#10;                        _cardItems.update { it + (link to items) }&#10;                    },&#10;                    onFailure = { _error.value = it.message ?: &quot;Failed to fetch items for $link&quot; }&#10;                )&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearData() {&#10;        _cardItems.value = emptyMap()&#10;        _error.value = null&#10;        _isLoading.value = false&#10;    }&#10;&#10;    fun clearError() {&#10;        _error.value = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package tv.nomercy.app.shared.stores&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.flow.*&#10;import kotlinx.coroutines.launch&#10;import tv.nomercy.app.shared.repositories.CardsRepository&#10;import tv.nomercy.app.shared.models.Component&#10;&#10;class CardsStore(&#10;    context: Context,&#10;    authStore: AuthStore,&#10;    private val serverConfigStore: ServerConfigStore&#10;) {&#10;    private val authService = GlobalStores.getAuthService(context)&#10;    private val repository = CardsRepository(context, authStore, authService)&#10;    private val scope = CoroutineScope(Dispatchers.IO)&#10;&#10;    private val _cardItems = MutableStateFlow&lt;Map&lt;String, List&lt;Component&gt;&gt;&gt;(emptyMap())&#10;    val cardItems: StateFlow&lt;Map&lt;String, List&lt;Component&gt;&gt;&gt; = _cardItems.asStateFlow()&#10;&#10;    private val _isLoading = MutableStateFlow(false)&#10;    val isLoading: StateFlow&lt;Boolean&gt; = _isLoading.asStateFlow()&#10;&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()&#10;&#10;    private fun getServerUrl(): String? = serverConfigStore.currentServer.value?.serverApiUrl&#10;&#10;    @Suppress(&quot;unused&quot;)&#10;    // Existing generic fetch by link&#10;    fun fetchCardItems(link: String, force: Boolean = false) {&#10;        val serverUrl = getServerUrl() ?: run {&#10;            _error.value = &quot;No server selected&quot;&#10;            return&#10;        }&#10;&#10;        if (!force &amp;&amp; _cardItems.value.containsKey(link)) return&#10;&#10;        scope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;&#10;            repository.getCardItems(serverUrl, link).collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { items -&gt;&#10;                        _cardItems.update { it + (link to items) }&#10;                    },&#10;                    onFailure = { _error.value = it.message ?: &quot;Failed to fetch items for $link&quot; }&#10;                )&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // New: fetch paginated letter-based cards (always use letter API)&#10;    fun fetchCards(type: String, char: Char = '_', force: Boolean = false) {&#10;        val serverUrl = getServerUrl() ?: run {&#10;            _error.value = &quot;No server selected&quot;&#10;            return&#10;        }&#10;&#10;&#10;        val link = &quot;music/$type/$char&quot;&#10;&#10;        if (!force &amp;&amp; _cardItems.value.containsKey(link)) return&#10;&#10;        val char = if (char == '#') '_' else char&#10;&#10;        scope.launch {&#10;            _isLoading.value = true&#10;            _error.value = null&#10;&#10;            repository.fetchCards(serverUrl, type, char).collect { result -&gt;&#10;                result.fold(&#10;                    onSuccess = { items -&gt;&#10;                        _cardItems.update { it + (link to items) }&#10;                    },&#10;                    onFailure = { _error.value = it.message ?: &quot;Failed to fetch items for $link&quot; }&#10;                )&#10;                _isLoading.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearData() {&#10;        _cardItems.value = emptyMap()&#10;        _error.value = null&#10;        _isLoading.value = false&#10;    }&#10;&#10;    fun clearError() {&#10;        _error.value = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>